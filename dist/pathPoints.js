"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getLUT=exports.pathStringToPathPoints=exports.linerizePolygon=exports.splitPolygon=exports.removePathPoint=exports.splitPath=exports.addPathPoint=exports.PathPoint=void 0;const points_1=require("./points");let{Bezier:Bezier}=require("bezier-js"),svgpath=require("svgpath");class PathPoint{constructor(code,point,cp1=null,cp2=null){this.code=code,this.point=point,this.cp1=cp1,this.cp2=cp2,this.isVisible=!0}}function addPathPoint(pathPoints,clickPoint,isCurved){let subparts=subParts(pathPoints),{pathPoint:pathPoint,pointOnPath:pointOnPath,length:length}=subparts.map((p=>getPointOnPath(p,clickPoint))).sort(((a,b)=>a.length-b.length))[0],actualPoint=length<10?pointOnPath:clickPoint,pPoints=subparts.find((p=>p.includes(pathPoint))),index=pPoints.indexOf(pathPoint);if("Z"===pathPoint.code&&pathPoint.point&&(pathPoint.point=null),"L"==pathPoint.code||"Z"===pathPoint.code)isCurved?("Z"===pathPoint.code&&(pathPoint.point=getNearestMPoint(pPoints,index).point),lineToQuadratic(pathPoint,actualPoint)):pPoints.splice(index,0,new PathPoint("L",actualPoint));else if(isCurved)"Q"==pathPoint.code&&quadraticToQubic(pathPoint,actualPoint);else{var pp=splitBezier(pPoints[index-1].point,pPoints[index],clickPoint);pPoints.splice(index,1,...pp)}return subparts.reduce(((prev,curr)=>[...prev,...curr]),[]).filter((p=>"Z"!=p.code||"Z"===p.code&&!p.point))}function splitPath(pathPoints,clickPoint){let subparts=subParts(pathPoints),{pathPoint:pathPoint,pointOnPath:pointOnPath}=subparts.map((p=>getPointOnPath(p,clickPoint))).sort(((a,b)=>a.length-b.length))[0],pPoints=subparts.find((p=>p.includes(pathPoint))),index=pPoints.indexOf(pathPoint);if("Z"===pathPoint.code&&pathPoint.point&&(pathPoint.point=null),pathPoint.cp1||pathPoint.cp2){let pp=splitBezier(pPoints[index-1].point,pPoints[index],clickPoint);pp.splice(1,0,new PathPoint("M",pp[0].point)),pPoints.splice(index,1,...pp)}else pPoints.splice(index,0,new PathPoint("L",pointOnPath),new PathPoint("M",pointOnPath));return"Z"!=pPoints[pPoints.length-1].code||pPoints[pPoints.length-1].point||replaceZPoint(pPoints,index),subparts.reduce(((prev,curr)=>[...prev,...curr]),[]).filter((p=>"Z"!=p.code||"Z"===p.code&&!p.point))}function removePathPoint(pathPoints,pointIndex,code){let pPoints=pathPoints.concat([]),point=pPoints[pointIndex];return"cp2"==code?point=cubicToQuadratic(point,2):"cp1"==code&&"C"==point.code?point=cubicToQuadratic(point,1):"cp1"==code&&"Q"==point.code?point=quadraticToLine(point):"point"==code&&deletePathPoint(pPoints,point),pPoints}function splitPolygon(pathPoints,p0,p1){let subparts=linerizePolygon(pathPoints),intersections=[];for(let i=0;i<subparts.length;i++){const part=subparts[i];for(let j=1;j<part.length;j++){let pPoint=part[j-1],point=part[j],inter=(0,points_1.linesIntersectionXY)(p0.x,p0.y,p1.x,p1.y,pPoint.x,pPoint.y,point.x,point.y);inter.onLine1&&inter.onLine2&&intersections.push(new points_1.Point(inter.point.x+2,inter.point.y+2))}}let _pathPoints=pathPoints;for(let i=0;i<intersections.length;i++)_pathPoints=clonePP(splitPath(_pathPoints,(0,points_1.roundPoint)(intersections[i],2)));return _pathPoints}function linerizePolygon(pathPoints){let subparts=subParts(clonePP(pathPoints)),result=[];for(let i=0;i<subparts.length;i++){const subpart=subparts[i],_subpart=[];result.push(_subpart);for(let j=0;j<subpart.length;j++){let pPoint=subpart[j-1],point=subpart[j],points=point.cp1||point.cp2?getLUT([pPoint.point,point.cp1,point.cp2,point.point].filter((p=>!!p)),10):["Z"==point.code?subpart[0].point:point.point];_subpart.push(...points)}}return result}function pathStringToPathPoints(d,t=null){let commands=[];try{let path=svgpath(d).unarc().unshort().abs();t&&path.transform(t).round(3),commands=path.segments}catch(e){return[]}let pathPoints=[];for(let index=0;index<commands.length;index++){let command=commands[index],prevPPoint=pathPoints[pathPoints.length-1]||null,newPPoint=new PathPoint(command[0].toUpperCase(),null);"M"==command[0]||"L"==command[0]||"C"==command[0]||"Q"==command[0]?(newPPoint.point=new points_1.Point(command[command.length-2],command[command.length-1]),"C"==command[0]?(newPPoint.cp1=new points_1.Point(command[1],command[2]),newPPoint.cp2=new points_1.Point(command[3],command[4])):"Q"==command[0]&&(newPPoint.cp1=new points_1.Point(command[1],command[2]))):"V"==command[0]?newPPoint.point=new points_1.Point(prevPPoint.point.x,command[1]):"H"==command[0]?newPPoint.point=new points_1.Point(command[1],prevPPoint.point.y):"Z"==command[0]&&(newPPoint.point=null),pathPoints.push(newPPoint)}return pathPoints}function subParts(pathPoints){let sp=[],part=null;for(let i=0;i<pathPoints.length;i++)"M"==pathPoints[i].code&&(part=[],sp.push(part)),part.push(pathPoints[i]);return sp.forEach((p=>{p.length>1&&"Z"!=p[p.length-1].code&&p.push(new PathPoint("Z",p[0].point))})),sp}function clonePP(pathPoints){return pathPoints.map((pp=>new PathPoint(pp.code,pp.point,pp.cp1,pp.cp2)))}function replaceZPoint(pathPoints,index){var _a;for(let i=0;i<=index;i++)pathPoints.push(...pathPoints.splice(0,1));for(let i=0;i<pathPoints.length;i++)if("Z"==pathPoints[i].code&&"M"==(null===(_a=pathPoints[i+1])||void 0===_a?void 0:_a.code)){pathPoints[i+1].code="L",pathPoints.splice(i,1);break}}function splitBezier(point,pathPoint,clickPoint){let pathPoints=[],bezier=createBezier(point,pathPoint),lut=getLUT([point,pathPoint.cp1,pathPoint.cp2,pathPoint.point].filter((p=>!!p)),30),len=0,fullLen=lut.reduce(((prev,curr,index)=>index>0?prev+(0,points_1.lineLength)(lut[index-1],curr):0),0);for(let i=0;i<lut.length;i++){let perp=(0,points_1.perpendicularToLine)(clickPoint,lut[i],lut[i+1]);if(perp.isInside){len+=(0,points_1.lineLength)(lut[i],perp.p);break}len+=(0,points_1.lineLength)(lut[i],lut[i+1])}let{left:left,right:right}=bezier.split(len/fullLen),lPoints=left.points,rPoints=right.points;return 3===left.points.length?(pathPoints.push(new PathPoint("Q",new points_1.Point(lPoints[2].x,lPoints[2].y),new points_1.Point(lPoints[1].x,lPoints[1].y))),pathPoints.push(new PathPoint("Q",new points_1.Point(rPoints[2].x,rPoints[2].y),new points_1.Point(rPoints[1].x,rPoints[1].y)))):(pathPoints.push(new PathPoint("C",new points_1.Point(lPoints[3].x,lPoints[3].y),new points_1.Point(lPoints[1].x,lPoints[1].y),new points_1.Point(lPoints[2].x,lPoints[2].y))),pathPoints.push(new PathPoint("C",new points_1.Point(rPoints[3].x,rPoints[3].y),new points_1.Point(rPoints[1].x,rPoints[1].y),new points_1.Point(rPoints[2].x,rPoints[2].y)))),pathPoints}function getPointOnPath(pathPoints,clickPoint){let min={len:Number.MAX_VALUE,pathPoint:null,pointOnPath:null};for(let index=1;index<pathPoints.length;index++){const p=pathPoints[index],pp=pathPoints[index-1];let subPoints=[];"Z"===p.code?subPoints=[pathPoints[index-1].point,getNearestMPoint(pathPoints,index).point]:!pp.point||p.cp1||p.cp2?p.cp1&&(subPoints=getLUT([pp.point,p.cp1,p.cp2,p.point].filter((p=>!!p)),10)):subPoints=[pp.point,p.point];for(let i=1;i<subPoints.length;i++){let perp=(0,points_1.perpendicularToLine)(clickPoint,subPoints[i-1],subPoints[i]);if(perp.isInside){let len=(0,points_1.lineLength)(perp.p,clickPoint);len&&len<min.len&&(min.len=len,min.pathPoint=pathPoints[index],min.pointOnPath=perp.p)}}}return{length:min.len,pathPoint:min.pathPoint,pointOnPath:(0,points_1.roundPoint)(min.pointOnPath,2)}}function cubicToQuadratic(point,cpIndexToRemove){return point.code="Q",point.cp1=1==cpIndexToRemove?point.cp2:point.cp1,point.cp2=null,point}function quadraticToLine(point){return point.code="L",point.cp1=null,point}function lineToQuadratic(point,cp){return point.code="Q",point.cp1=cp,point}function quadraticToQubic(point,cp){return point.code="C",(0,points_1.lineLength)(cp,point.point)<(0,points_1.lineLength)(point.cp1,point.point)?point.cp2=cp:(point.cp2=point.cp1,point.cp1=cp),point}function deletePathPoint(points,point){let index=points.indexOf(point);points.splice(index,1),"M"==point.code&&points[index]&&(points[index].cp1=points[index].cp2=null,points[index].code="M");for(let i=0;i<points.length-1;i++)if("M"===points[i].code&&"M"===points[i+1].code){points.splice(i,1);break}return points}function getNearestMPoint(points,index){for(let i=index;i>=0;i--)if("M"===points[i].code)return points[i]}function createBezier(point,pathPoint){var _a,_b,_c,_d;return new Bezier(...[point.x,point.y,pathPoint.cp1.x,pathPoint.cp1.y,null!==(_b=null===(_a=pathPoint.cp2)||void 0===_a?void 0:_a.x)&&void 0!==_b?_b:null,null!==(_d=null===(_c=pathPoint.cp2)||void 0===_c?void 0:_c.y)&&void 0!==_d?_d:null,pathPoint.point.x,pathPoint.point.y].filter((p=>null!=p)))}function getLUT(points,steps=100){let lut=[];steps++;for(let i=0;i<steps;i++){let t=i/(steps-1),p=(0,points_1.round)(compute(t,points),3);lut.push(p)}return lut}function compute(t,points){let p=points;if(0===t)return points[0];const order=points.length-1;if(1===t)return points[order];const mt=1-t;if(0===order)return points[0];if(1===order){return{x:mt*p[0].x+t*p[1].x,y:mt*p[0].y+t*p[1].y,t:t}}let a,b,c,mt2=mt*mt,t2=t*t,d=0;2===order?(p=[p[0],p[1],p[2],{x:0,y:0}],a=mt2,b=mt*t*2,c=t2):3===order&&(a=mt2*mt,b=mt2*t*3,c=mt*t2*3,d=t*t2);return{x:a*p[0].x+b*p[1].x+c*p[2].x+d*p[3].x,y:a*p[0].y+b*p[1].y+c*p[2].y+d*p[3].y,t:t}}exports.PathPoint=PathPoint,exports.addPathPoint=addPathPoint,exports.splitPath=splitPath,exports.removePathPoint=removePathPoint,exports.splitPolygon=splitPolygon,exports.linerizePolygon=linerizePolygon,exports.pathStringToPathPoints=pathStringToPathPoints,exports.getLUT=getLUT;