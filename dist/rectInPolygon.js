"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getRectForPolygon=void 0;const points_1=require("./points");function getRectForPolygon(points){const result=centroidRect(points);return null==result?gGetRect(controlPoints(points.map((p=>new points_1.Point(Math.round(p.x),Math.round(p.y)))))):result}function controlPoints(points){var newPoints=[];let addnewPoint=(index,point)=>{points.find((p=>samePoint(p,point)))||newPoints.find((np=>np[0]==index&&samePoint(np[1],point)))||newPoints.push([index,point])};for(var lines=[],i=0;i<points.length-1;i++)lines.push(new points_1.Line(points[i],points[i+1]));for(let i=0;i<lines.length;i++){let line1=lines[i];for(let j=0;j<points.length;j++){let point=points[j];if(!(0,points_1.pointIsOnLine)(point,line1.p0,line1.p1)){var perp=(0,points_1.perpendicularToLine)(point,line1.p0,line1.p1);perp.isInside&&addnewPoint(lines.indexOf(line1),perp.p)}}for(let k=0;k<lines.length;k++){let line2=lines[k];if(line1!=line2){var inter=(0,points_1.linesIntersectionXY)(line1.p0.x,line1.p0.y,line1.p1.x,line1.p1.y,line2.p0.x,line2.p0.y,line2.p1.x,line2.p1.y);(inter.onLine1||inter.onLine2)&&(inter.onLine1?addnewPoint(lines.indexOf(line1),inter.point):addnewPoint(lines.indexOf(line2),inter.point))}}}var allPoints=[];for(i=0;i<lines.length;i++){var p0=lines[i].p0;allPoints.find((ap=>samePoint(ap,p0)))||allPoints.push(new points_1.Point(p0.x,p0.y)),newPoints.filter((n=>n[0]==i)).sort((p=>(0,points_1.lineLength)(p[1],p0))).forEach((np=>{allPoints.find((ap=>samePoint(ap,np[1])))||allPoints.push(new points_1.Point(np[1].x,np[1].y))}))}return allPoints}function samePoint(p1,p2,minDistance=1){return(0,points_1.lineLength)(p1,p2)<=minDistance}function gGetRect(points){for(var area=0,rect=[],centerPoints=[],pi=1;pi<points.length;pi++)centerPoints.push((0,points_1.pointsCenter)(points[pi],points[pi-1]));for(var i=0;i<points.length-3;i++)for(var first=points[i],j=i+1;j<points.length-2;j++)for(var second=points[j],k=j+1;k<points.length-1;k++)for(var third=points[k],l=k+1;l<points.length;l++){var r=[first,second,third,points[l],first],a=rectArea(r);isRect(r)&&a>area&&!centerPoints.find((p=>(0,points_1.pointInsidePolygon)(p,r,!0)))&&!points.find((p=>(0,points_1.pointInsidePolygon)(p,r,!0)))&&(area=a,rect=r)}return rect}function rectArea(points){return isRect(points)?(0,points_1.lineLength)(points[0],points[1])*(0,points_1.lineLength)(points[1],points[2]):0}function isRect(points){if(5!=points.length&&4!=points.length)return!1;var first=points[0],second=points[1],third=points[2],fourth=points[3];return Math.round(Math.abs((0,points_1.lineAngle)(first,second)-(0,points_1.lineAngle)(second,third)))%90==0&&Math.abs((0,points_1.lineLength)(first,second)-(0,points_1.lineLength)(third,fourth))<2&&Math.abs((0,points_1.lineLength)(second,third)-(0,points_1.lineLength)(fourth,first))<2}function centroidRect(points){var _a,_b,_c,_d,center=(0,points_1.сentroid)(points);if(!(0,points_1.pointInsidePolygon)(center,points))return null;for(var polyRect=(0,points_1.calculateBoundsRect)(points),maxArea=0,maxPoints=null,edgeOffsetLeft=null!==(_a=nearestIntersection(center,(0,points_1.shiftPoint)(center,polyRect.width,180),points))&&void 0!==_a?_a:polyRect.width,edgeOffseTop=null!==(_b=nearestIntersection(center,(0,points_1.shiftPoint)(center,polyRect.height,270),points))&&void 0!==_b?_b:polyRect.height,edgeOffseRight=null!==(_c=nearestIntersection(center,(0,points_1.shiftPoint)(center,polyRect.width,0),points))&&void 0!==_c?_c:polyRect.width,edgeOffseBottom=null!==(_d=nearestIntersection(center,(0,points_1.shiftPoint)(center,polyRect.height,90),points))&&void 0!==_d?_d:polyRect.height,left=1;left<=edgeOffsetLeft;left+=edgeOffsetLeft/20)for(var top=1;top<=edgeOffseTop;top+=edgeOffseTop/20){var p0=new points_1.Point(center.x-left,center.y-top);if(!(0,points_1.pointInsidePolygon)(p0,points))break;for(var right=1;right<=edgeOffseRight;right+=edgeOffseRight/20){var p1=new points_1.Point(center.x+right,center.y-top);if(!(0,points_1.pointInsidePolygon)(p1,points))break;for(var bottom=1;bottom<=edgeOffseBottom;bottom+=edgeOffseBottom/20){var p2=new points_1.Point(center.x+right,center.y+bottom),p3=new points_1.Point(center.x-left,center.y+bottom);if(!(0,points_1.pointInsidePolygon)(p2,points)||!(0,points_1.pointInsidePolygon)(p3,points))break;var rect=[p0,p1,p2,p3,p0];if(!(0,points_1.intersectPolygons)(rect,points)){var area=rectArea(rect);area>maxArea&&(maxArea=area,maxPoints=rect)}}}}return null==maxPoints?null:maxPoints}function nearestIntersection(p0,p1,points){let interPoints=[];for(var i=1;i<points.length;i++){var inter=(0,points_1.linesIntersectionXY)(p0.x,p0.y,p1.x,p1.y,points[i-1].x,points[i-1].y,points[i].x,points[i].y);inter.onLine1&&inter.onLine2&&interPoints.push(inter.point)}if(0==interPoints.length)return null;var shortest=interPoints.sort((o=>(0,points_1.lineLengthXY)(p0.x,p0.y,o.x,o.y)))[0];return(0,points_1.lineLengthXY)(p0.x,p0.y,shortest.x,shortest.y)}exports.getRectForPolygon=getRectForPolygon;